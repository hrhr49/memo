---
title: "Vim チートシート"
date: 2020-09-15T21:09:21+09:00
draft: true
tags: ["Vim", "cheatsheet"]
---

# TODO

全然整理できていない。まとめ次第、draftをfalseにする。

# 繰り返し処理

* `.` : 前の編集をもう一度
* `n` : 前回の検索での次の候補に移動
* `N` : 前回の検索での前の候補に移動
* `;` : 前回のf,tコマンドでの次の文字に移動
* `,` : 前回のf,tコマンドでの前の文字に移動
* `@:` : exコマンド
* `@@` : マクロ
* `&` : substituteコマンド
* `<C-@>` : 挿入モードのときに、前回の挿入モードでの入力を入力してノーマルモードへ。
* `<C-a>` : こっちも上記と同じだが、ノーマルモードへ遷移しない
* `!!` : 外部コマンド


# テキストオブジェクト

* `gn` : 次の検索マッチ全体(7.3以上)
* `gN` : 前の検索マッチ全体(7.3以上)


# 大文字、小文字の変換

* `gu` : 小文字に変換
* `gU` : 大文字に変換
* `~` : 大文字と小文字を入れ替え


# 移動関係

* `H` : 画面上部に移動
* `M` : 画面中央に移動
* `L` : 画面下部に移動
* `zt`, `z <Enter>` : カーソル行を画面の上部に移動
* `zz`, `z.` : カーソル行を画面の中央に移動
* `zb`, `z-` : カーソル行を画面の下部に移動
* `f {char}` : その行のcharまで移動
* `F {char}` : `f` と同じだが逆方向に移動
* `t {char}` : その行のchar直前まで移動
* `T {char}` : `t` と同じだが逆方向に移動
* `gf` : カーソル上のファイル名のファイルへジャンプ
* `gF` : `gf` と同様だが、ファイル名の後ろに行番号を指定できる。
    - 以下のフォーマットが使用可能
        - `eval.c:10` : `eval.c` の10行目
        - `eval.c @ 20` : `eval.c` の20行目
        - `eval.c (30)` : `eval.c` の30行目
        - `eval.c 40` : `eval.c` の40行目
* `gx` : カーソル上のファイルをデフォルトのアプリで開く
* `[i` : インクルードファイルまで検索し、カーソルのキーワード
  の最初の出現を表示(Pythonのimportにも対応)
* `[I` : インクルードファイルまで検索し、カーソルのキーワードの出現を一覧表示
* `[<C-i>` : インクルードファイルまで検索し、カーソルのキーワードの最初の出現位置へジャンプ
* `[d` : `[i`のマクロ定義バージョン。D, `<C-d>`も同様に使用可能
* `:browse oldfiles` : 最近使ったファイル一覧を出し、移動`:bro ol`でOK
* `g;` : 変更した箇所に戻る
* `g,` : 変更した箇所に進む
* `gi` : 前回の挿入モードに入った箇所へ行って挿入モード
* `:jumps` : ジャンプリスト表示
* `:changes` : 変更リスト表示
* `{` : 段落単位で上に移動
* `}` : 段落単位で下に移動
* `[m` : 関数の定義はじめへ移動(上方向)
* `[M` : 関数の定義終わりへ移動(上方向)
* `]m` : 関数の定義はじめへ移動(下方向)
* `]M` : 関数の定義終わりへ移動(下方向)
* `[#` : 外側の`#if`,`#ifdef`などへジャンプ
* `[{` : 外側の`{`へジャンプ


# モード切替

* `o` : 挿入モードになり、次の行から始まる。
* `O` : 挿入モードになり、前の行から始まる。
* `R` : 置換モードに入る。このモードだと文字があるところは上書きして編集できる。抜け方は挿入モードからの抜け方と同じ。
* `gR` : 仮想置換モード。Rだと全角に対応していないが、こっちは対応。めっちゃ便利
* `Esc`, `<C-[>` : normalモードになる。
* `i` : 挿入モードになる。
* `I` : その行の最初の非空文字の場所から挿入モードになる。


# バッファ操作

* `:bn` : 次のバッファに切り替え
* `<C-o>` : 直前に編集していた場所へジャンプ
* `<C-i>` : 上の逆
* `<C-^>` : 直前に編集していたバッファにジャンプ
* `<C-t>` : 直前に編集していたバッファにジャンプ
* `:pop` : 上に同じ
* `<C-]>` : カーソル上の関数名やクラス名の定義元へジャンプ
* `:e {filename}` : 新規バッファ作成
* `:bd` : バッファ削除
* `:ls` : バッファ一覧表示
* `:enew` : カレントウィンドウに新規バッファ
* `:new` : 水平分割で新規バッファ(`<C-w>n`も同じ)
* `:vnew` : 垂直分割で新規バッファ


# 検索

* `/{word}` : wordを検索(\cをwordの頭につけると大文字小文字を無視)
* `/{word}/{offset}` : wordを検索
* `/\v...` : very magicモードで検索。正規表現を使うときに便利。
* `/\V...` : no magicモードで検索。テキストで検索するときに便利。
* `?{word}` : 上とは逆方向に検索
* `*` : カーソル上の単語を検索
* `#` : カーソル上の単語を検索(上の方へ検索)
* `:g/word` : wordを含む行の一覧を表示
* `:g/word/d` : wordを含む行を削除
* `:g/word/ cmd` : wordを含む行にcmdを実行
    - `:if {expr} | {cmd}`と組み合わせて使うと便利
        - `:g/pattern/ if getline('.') =~ 'pattern' | {cmd}` : パターンに一致する行を対象に `{cmd}` を実行
        - `:g/pattern/ if getline('.') !~ 'pattern' | {cmd}` : パターンに一致しない行を対象に `{cmd}` を実行
        - `:g/pattern/ if line('.') % 2 == 0 | {cmd}` : 偶数行に実行
* `:v/word` : wordを含まない行の一覧を表示
* `:set incsearch` : インクリメンタル検索にする


## 大文字小文字について
検索時に大文字小文字を無視する際には`:set ignorecase`を使う。
検索文字列に大文字が含まれたときには無視しないようにするには
`:set ignorecase`と`:set smartcase`の両方を指定する。

# 正規表現
* `\_s` : 空白または改行文字

# ウィンドウ関係

* `:vsp` : 縦分割
* `:sp` : 横分割
* `:clo[se]` : ウィンドウを閉じる
* `<C-w>c` : ウィンドウを閉じる
* `:on[ly]` : 自分以外のウィンドウをすべて閉じる
* `<C-w>o` : 自分以外のウィンドウをすべて閉じる
* `:q` : ウィンドウの削除
* `:new filename` : 新規ウィンドウ作成(水平分割)
* `:vnew filename` : 新規ウィンドウ作成(垂直分割)
* `<C-w> w` : ウィンドウ移動
* `<C-w> h` : 左のウィンドウへ移動
* `<C-w> j` : 下のウィンドウへ移動
* `<C-w> k` : 上のウィンドウへ移動
* `<C-w> l` : 右のウィンドウへ移動
* `<C-w> H` : カレントウィンドウを左へ移動
* `<C-w> J` : カレントウィンドウを下へ移動
* `<C-w> K` : カレントウィンドウを上へ移動
* `<C-w> L` : カレントウィンドウを右へ移動
* `<C-w> q` : カレントウィンドウを閉じる
* `<C-w> =` : ウィンドウサイズを揃える
* `<C-w>_` : ウィンドウの高さ最大
* `[N]<C-w>_` : ウィンドウの高さN行
* `<C-w>|` : ウィンドウの幅最大
* `[N]<C-w>|` : ウィンドウの幅N文字
* `<C-w> o` : 他のすべてのウィンドウを閉じる
* `:winc[md] {char}` : `<C-w>`の代わりに`:winc[md]`を使っても良い。
* `<C-w> >` : 幅を大きくする
* `<C-w> <` : 幅を大きくする
* `:res[ize] N` : 高さをNにする(+-で相対的にもできる)
* `:vert[ical] res[ize] N` : 幅をNにする(+-で相対的にもできる)
* `:ba[ll]` : バッファすべてをウィンドウ化
* `<C-w> <C-]>` : タグジャンプを新しいウィンドウで開く
* `<C-w> f` : ファイルへジャンプし、新規ウィンドウで開く
* `<C-w> gf` : ファイルへジャンプし、新規タブで開く
* `<C-w> T` : 現在のウィンドウを新規タブで開く
* `<C-w> s` : 水平分割
* `<C-w> v` : 垂直分割




# 画面スクロール

* `<C-u>` : 半画面上スクロール
* `<C-d>` : 半画面下スクロール
* `<C-b>` : 一画面上スクロール
* `<C-f>` : 一画面下スクロール
* `<C-y>` : 一行上スクロール
* `<C-e>` : 一行したスクロール
* `zt` : 現在の行を画面の第一行目にする。
* `zz` : 現在の行を画面の真ん中にする。
* `zb` : 現在の行を画面の最終行にする。


# タブ操作

* `:tabnew` : 新規タブ作成、ファイル名を指定可能、ディレクトリからもOK
* `:tabe` : 上に同じ
* `gt` : 次のタブに移動(数字指定するとその数字番目のタブに移動する)
* `gT` : 前のタブに移動
* `:tabc[lose]` : タブを削除
* `:tabo[nly]` : アクティブなタブ以外を消す。
誤り->
* `:tab b bufname` : bufnameを新規タブで開く
* `:tabnew | b 1` : バッファ番号1のバッファを新規タブで開く
* `:tabnew | #1` : バッファ番号1のバッファを新規タブで開く
* `:tab help keyword` : keywordのhelpを新規タブで開く
* `<C-w>T` : 現在のウィンドウをタブ化
* `:tabn[ext] [N]` : 番号Nのタブへ
* `:tabmove [N]` : タブの位置を変更(0で先頭、なしで最後)
* `:tab ba` : バッファすべてをタブ化


# 入力補完

* `<C-x> <C-f>` : ファイル名補完
* `<C-x> <C-l>` : 行補完
* `<C-x> <C-i>` : インクルードファイルも含めて補完
* `<C-p>` : 単語補完、前方探索
* `<C-n>` : 単語補完、後方探索
* `<C-y>` : 候補の確定
* `:set completeopt+=longest` : 複数候補あるときに、共通部分まで入力される
* `:set iskeyword+=-` : 補完に使用する文字に`-`を追加。htmlなど
の編集時に便利(setlocalを使用しよう)


## exコマンドなどの補完
* `:set wildmenu` : tabを押したときに候補が出るようにできる。
* `:set wildignorecase` : 補完の際に大文字小文字を区別する。

## wildmenu

wildmenuを有効にしておくと、コマンドラインでTab補完するときに候補一覧が表示される。
このとき、ファイルを補完しているとき、以下のキーバインドが便利

* `<Up>` : フォルダを上の階層へ
* `<Down>` : フォルダを下の階層へ

# 置換操作
* `:s/old/new/` : 現在の行での置換
* `:s/old/new/g` : 現在の行での置換(複数適用)
* `%s/old/new/` : すべての行での置換
* `:s/old/new/i` : 現在の行での大文字小文字を無視して置換
* `:s#old#new#` : スラッシュ以外の記号でもOK
* `:s/old/\={expr}/g` : vimscriptの結果で置換

# レジスタ関係
挿入モード時に `<C-r>` を押すことでレジスタを指定して貼り付けられる。
特に、`<C-r> =` でvimscriptの式の結果を挿入できるので便利かもしれない。
* `:put a` : aレジスタの内容を現在の下の行に貼り付け
* `gP` : `P`と同じだが、貼付け後のカーソル位置は貼り付けた最後の位置

## exコマンドからレジスタの設定

以下のようにする。`+`レジスタや`*`レジスタに設定すれば、クリップボードに文字列を格納できる。
```
:let @+='this is content'
```

この`+`の部分はレジスタ名なので、他のレジスタに好きに置き換えて良い。  
`/`,`.`,`:`などのレジスタを変更すると楽しいかも?

### 他の使用例など
現在の絶対パスをクリップボードに入れる(linuxじゃない場合は`*`レジスタ?)
```
:let @+=system('pwd')
```

# マーク
マークに小文字を使うと、ファイル内のみ有効。
大文字ならファイルをまたいで移動可能。

* `ma` : 現在のカーソル位置をマーク名aに保存
* `'a` : マーク名aの行頭に移動
* `\`a` : マーク名aに移動
* `'^' : 直前の挿入モード終了箇所
* `'.` : 直前の変更箇所
* `'<` : 直前の選択箇所先頭
* `:marks` : マーク名一覧を表示

# カレントワーキングディレクトリの移動
* `:cd {dirpath}` : dirpathに移動
* `:lcd {dirpath}` : そのバッファだけでcwdを移動
* `:set autochdir` : 自動的に移動されるように設定
* `:cd %:h` : この操作で開いているファイルがあるディレクトリに移動できる(lcdでも同様)
* `:pwd` : 現在の場所を表示

# 折りたたみ
* `zf` : 折りたたみ,テキストオブジェクト使用可能
* `space` : その行の折りたたみの展開 zoでもOK
* `zc` : 折りたたみを閉じる
* `zd` : 折りたたみを削除する
* `zr` : すべての折りたたみを開く
* `zR` : すべての折りたたみを開く(再帰的に)
* `zm` : すべての折りたたみを閉じる
* `zM` : すべての折りたたみを閉じる(再帰的に)
* `zE` : すべての折りたたみを削除
* `:set foldcolumn=1` : 折りたたみを可視化するための列を左端に追加(1は列数)
* `:set foldmethod=indent` : インデントで折りたたみ
* `:set foldmethod=marker` : マークで折りたたみ
* `:set foldmethod=indent`を使えば、折り畳みをインデントで指定できる。
* `:set foldnestedmax=1`とすれば、ネストの深さを1に設定できる。
* `foldmethod`には他にも色々あり、特定の文字で折りたたみを作成も可能。
* `[z`, `]z` : 現在開いている折りたたみの開始/終了位置へ移動
* `zj`, `zk` : 次の折りたたみの開始/終了位置へ移動
* `za` : 折りたたみを開く/閉じる
 `:set foldlevel=0` : すべての折りたたみを閉じる。モードラインと併用すると便利。

# ターミナル
* :ter ターミナルを開く。Vim 8からの機能
ターミナルウィンドウではiでコマンドモード、ノーマルへ行くにはC-\ C-nを
する（覚えづらい）  
補足): ターミナルでノーマルモードに入って`<C-w> gf`などでファイルを開ける


# Exモードの便利なコマンド
* `:%normal i//` : すべての行の先頭に//を挿入
* `:%normal xx` すべての行の先頭2文字を削除
* `:6t.` 6行目の内容を現在の行の直後に貼り付ける。
* `:4,7mG`  4~7行目の内容を最後の行の直後に移動。
補足)ビジュアルモード中に:でそのレンジを考慮してくれるから便利!
* `:sh` シェルを開く
* `:r` (filename) filenameの内容を貼り付け
* `:r!` (command) シェルコマンド出力を貼り付け
ちなみに:normalは:normでOK
* `:%norm I#include<jjA>` ちなみに、Iはiでも可
`:'<,'>norm I#include<jjA>` というふうになる
* コメントアウトを消したい時には
* `:%norm xx xx` をすべての行に適用するので、先頭に文字を削除できる。
* :normal . を複数範囲で行うのは強力！
* :normal @qみたいなのは更に複雑な作業を可能にする!!
* exコマンドは@:で繰り返し可能、その後は@@で繰り返せる。
* exコマンド入力中にはtabキーで補完ができる。
* `<C-d>` : 補完予測一覧を表示できる。
* `:colorscheme <C-d>` : 色一覧が表示される

* Ctrl + c こっちだと、いくつかの処理がキャンセルされるかも（仕様）
* `<C-p>` : コマンド履歴を遡る
* `<Up>` : コマンド履歴を遡る。(途中まで入力すれば、それに応じてフィルターされる)
* `<C-n>` : `<C-p>`の逆
* `<Down>` : `<Up>`の逆
* `:edit %<Tab>` : `%`などの記号は`<Tab>`で展開できる(Windowsだと`%:r`を
使う必要ある?また、ファイル名入力の文脈でしかうまくいかないっぽい)

* `:g/keyword` : keywordが含まれる行を一覧表示
* `:g/keyword/d` : keywordが含まれる行を削除
* `:g/keyword/y A` : keywordが含まれる行をaレジスタに追記(事前にqaqなどでレジスタのクリアするべき)
* `:g/keyword/t$` : keywordが含まれる行をファイル末尾に追記
* `:g/{/ .+1,/}/-1 sort` : すべての中カッコ内をソート(開きカッコ直後と閉じカッコ直前に改行あること前提)
* `:g/{/ .+1,/}/-1 >` : すべての中カッコ内のインデント増やす
* `:g/{/sil .+1,/}/-1 >` : すべての中カッコ内のインデント増やす(メッセージをださない)
* `:v/keyword/d` : keywordが含まれない行を削除
* `:bro ol` : 最近使ったファイル一覧表示と移動
* `:filter /pattern/ cmd` : cmdの出力で、patternに合致するものだけ表示
`ls`コマンドや`oldfiles`コマンドなどに使用すると良さそう。
!をつけると逆にマッチしないほうを表示する。

# 外部コマンドとの連携
* `:!(command)` : commandを実行(補足commandには`!`を含める際にエスケープしなくちゃうまく行かない)
* `:r!(command)` : commandの標準出力結果を貼り付け
* `(range):!(command)` : rangeを標準入力に与えてcommandを実行し、標準出力結果で置き換える(ビジュアルモードで便利)
sort, grep , awkあたりと組み合わせたら面白そう
* `:1,$!awk '{seen[$0]++==0}'` : 行をユニークにするコマンド。`==0`でなく`!`を使う際には`\!`と記述すること！
なお、ビジュアルモード中に!をタイプすれば自動的に:!まで入力される。
* `make` : makeを行う。エラーはquickfixに入るっぽい
* `grep` : grepを行う。


# 小ネタ
Ctrl + MでEnterキーと同じ->じつは Ctrl + jでも良かった。こっちのがいい  
Ctrl + hでBackSpaceと同じ  
Ctrl + wでカーソル前の単語を削除（挿入モード）  
Ctrl + uでカーソル前のその行を削除（挿入モード）
  
dib で()内を削除  
diB で{}内を削除

# 複数行をまとめてコメントアウト
ctrl+vで矩形ビジュアルモードを使えば良い。
ctrl+vで範囲を選び、0で行頭まで選択、Iで行頭から挿入モードになり、
//や#などのコメント要素を書いた後、ノーマルモードに戻ると、他の行にも
同じ編集ができる。
0,Iを$,Aに変えると、行末尾の編集もできる。

# クリップボードの内容を貼り付け
`"*p`
もしくは
`"+p`

クリップボードにコピー
"+y

## 補足
どうやら、通常は`*`レジスタに保存されるが、linuxの場合は`+`のほうが
優先されるっぽい。以下のように設定しとくとvimで使うレジスタを`*`や`+`に
設定できて便利

* `:set clipboard^=unnamed` Windowsやmacでの設定
* `:set clipboard^=unnamedplus` linuxでの設定

レジスタ関連
レジスタ名は
`"0~"9`
`"a~"z`
`"+,"*,"=`
などがある。
数字には通常ヤンクしたものが次々に入っていく。
アルファベットは自分で使えるので便利
`"+`,`"*`はOSのクリップボード？
"=は計算結果を入れられる？

`"1p`を`.`で繰り返すと、2,3,4...のレジスタ内容が次々取り出せる。
`u.`を繰り返せば、貼り付ける内容を変えていくことができる。
参照： [Vim Tips](https://vim.fandom.com/wiki/Remembering_previous_deletes/yanks)

# レジスターの内容一覧を見る。
:reg

"aレジスタへのヤンク
"ayyなど
"aレジスタの内容を貼り付け
"apなど
これらはもちろん範囲を好きなように指定できる。
挿入モードで"aレジスタの貼り付け
`<Ctrl-r>a`
これは便利
`<Ctrl-r>=`
で計算結果をそのまま入れられるのは便利


# マクロ
* `qa` : (操作) q aレジスタにマクロを登録する。aを他の文字にすれば、他の文字でもOK。
* `@a` : aレジスタの内容を実行。特定範囲のテキストをyyでコピーして`:@"`で実行すると便利
* `qA` : aレジスタにマクロを追記(末尾に追加)する。

# ctagsとの連携
ctagsコマンドとの連携で関数やクラスの定義場所までジャンプができる
準備
sudo apt-get install ctags
でctagsコマンドを入れる
該当のディレクトリでctags -Rコマンドを実行したら
tagsファイルが生成され、それを参考にvimうえでタグジャンプできるようになる。
vim上での操作方法
ctrl + ] これを関数名のうえで実行すると、関数の定義元にジャンプする。
g ctrl + ] 複数候補があるときにリスト形式で出してくれ、ジャンプできる。
ctrl + t タグジャンプの直前に戻る。ctrl + o , ctrl + iよりも便利?
ctrl + o で元のバッファに戻れる
ctrl + i で進む(ctrl + o の逆)

* `:tag keyword`  keywordタグにジャンプ
* `:tag /keyword` keywordを含むタグにジャンプ
* `:tag /^keyword` keywordで始まるタグにジャンプ

補足)/から始まる場合は正規表現を受け付ける  
なお、`:ta`でもOK。ジャンプではなく、一覧を出してジャンプしたいときには`:ts`を使う(tselect)。

# 起動オプション
-p タブで開く

# 関数定義、マクロ定義へのジャンプのやり方（ctag不要）
`[ C-I`

# ファイル名に関する表記
* `%` : 現在のファイル名
* `%<` : 拡張子を除いたファイル名
* `%:h` : ファイルがあるディレクトリ名
* `%:t` : ファイル名
* `%:r` : 拡張しなし
* `%:e` : 拡張子のみ(例txt)
* `%:p` : フルパス

# コマンドモードでの色々

* `<C-r> <C-w>` : カーソル位置ある文字列(word)を入力
* `<C-r> <C-a>` : カーソル位置ある文字列(WORD)を入力
* `:vim aiueo *| cw` : 現在のディレクトリ内ファイルで、aiueoを含む箇所を
一覧で表示。なお、検索単語を/.../で囲むと正規表現として解釈される。
* `<C-d>` : 入力候補を表示


## 折り畳みの操作コマンド
* `zo` : カーソル化の折りたたみを位置段階開く
* `zO` : カーソル化の折りたたみを総べて開く
* `zc` : カーソル化の折りたたみを位置段階閉じる
* `zC` : カーソル化の折りたたみを全て閉じる
* `zm` : 折り畳みを全て位置段階開く
* `zM` : 折りたたみを全て開く
* `zr` : 折りたたみを全て1段階閉じる
* `zR` : 折りたたみを全て閉じる

## アンドゥツリー
* `:undol[ist]` : アンドゥツリーの葉にあたるノード情報を表示。各編集には番号が振ってあり、
それをundo numberと呼ぶ。
* `:u[ndo] {N}` : undo numberがNのものを復元
* `g-`, `g+` : 時間軸に従ってundo/redo(通常のundoはアンドゥツリーを遡る仕様)
* `:earler {count}`, `after {count}` : `g-`, `g+`と同様
* `undotree()` : アンドゥ情報を辞書で取得

# ヘルプメモ
* `:help keyword` : keywordのヘルプ画面を開く
* `:help i^n` : 挿入モードでの(insertのi)`<C-n>`(文字通りハットでOK)を検索
* `:help CTRL-g` : `<C-g>`のヘルプを検索
* `:help i_CTRL-g` 挿入モードでの`<C-g>`を検索
* `options, quickref, tips` : 役立ちそうなhelp内容たち
* `usr_toc, reference_toc, key-mapping function-list` : 役立ちそうなhelpたち
* `:helpgrep {word}` : ヘルプでGrep検索かける

# 起動オプション
* `-u NONE -U NONE --noplugin` : 色々無効化して起動


# quickfixメモ
* `:vim sometext ** | cw` などとすると、grep結果をリストで表示するウィンドウが
できる。これはquickfixというやつらしい。このリストの項目上でenterを押すと、その場所
にジャンプできる。
* ちなみに、vimでgrepするときに、/.../のようにスラッシュで囲むと正規表現として検索される。
* vimではなく、grepでもOKだが、この場合はcwを使用できない。しかしこっちのが高速。
* vimの方だとワイルドカードに`**`が使用でき、再帰的な検索ができる(`**`の部分はディレクトリまでの部分にマッチするみたい。
だから、再帰的なファイルの検索の場合は`**/*`を使えば良い)。(grepにrオプションを渡せば
grepでも同様のことができる。)
* `:args`コマンドで、対象ファイルを設定しておくと便利。`##`でargsコマンドで設定したファイルが指定できる。
* `:copen` を使うと前回行ったgrep結果をquickfixウィンドウで出せる。
* `:cw` : `:copen`と同じ？
* `:cn` : 次の検索候補へ移動
* `:cN`, `:cp` : 前の検索候補へ移動
* `:ccl` : quickfixウィンドウを消す

バッファの中でgrepしたいときのコンボ
1. `:cexpr ""` : quickfixをクリア
2. `:bufdo vimgrepadd /foo/ %` : fooを全バッファで検索
3. `:cw` : quickfixウィンドウを開く


何度も同じ検索範囲で検索するのはだるい..。
```
:vim foo path/to/search/dir/**
:vim bar path/to/search/dir/**
:vim baz path/to/search/dir/**
:vim hoge path/to/search/dir/**
:vim piyo path/to/search/dir/**
```

しかし、`:ar`コマンドを使用すれば、これを回避できる。

```
:ar path/to/search/dir/**
:vim foo ##
:vim bar ##
:vim baz ##
:vim hoge ##
:vim piyo ##
```
`:ar`で指定した値を`##`で使用できる。

なお、バックスラッシュで囲んであげると、シェルの標準出力を受け取れる。
```
:ar `find . -name \\*.rb`
```

# diffのとり方
* `:diffthis` : このコマンドを各ウィンドウでじっこうすればdiff取れる。これがベスト!
* `:vertical diffsplit filename` : filenameとのdiffを立て分割で出す。なお、
`:vertical`は`:vert`に、`diffsplit`は`diffs`に省略可能。実は、
diffoptにverticalを設定しておけば、verticalは書かなくても良い。
```
:set diffopt=vertical
```
* `:diffupdate` : diff結果を更新する。
* `vimdiff file1 file2`, `vim -d file1 file2` : コマンドラインからdiffを取れる。
* `[c` : 次のdiff箇所へ移動
* `]c` : 前のdiff箇所へ移動
* `do` : もう一方のウィンドウ内容をこっちに取り込む
* `dp` : 現在のウィンドウ内容をもう一方へコピー
* `:diffupdate` : diff状態をアップデート
* 参考リンク [https://rcmdnk.com/blog/2016/02/26/computer-vim/](https://rcmdnk.com/blog/2016/02/26/computer-vim/)

なお、Gitでのdiffで一時的に使いたいときには次のコマンドでOK(もちろん、デフォルトのdiffツールに設定可能)

```
git difftool --tool=vimdiff --no-prompt
```

# netrwまとめ

* `i` : 見た目を変える
* `gn` : ツリーのルートを現在のディレクトリにする
* `v` : 垂直分割でファイルを開く
* `o` : 水平分割でファイルを開く
* `d` : ディレクトリ作成
* `c` : 現在のディレクトリを変更
* `gh` : ドットから始まるファイルを隠す
* `mt` : コピーや移動先のためのマークをつける
* `mt` : コピーや移動などの対象を選ぶためのマーク/解除。太字になる。
* `mc` : ファイルコピー
* `mu` : 全てのマーク解除
* `mr` : ワイルドカードでのマーク
* `mm` : ファイル移動
* `md` : diffをとる
* `:E **/*.py` : 再帰的にpyファイルを検索。`<s-up>`,`<s-down>`で候補を移動
* `u` : 戻る(直前の場所に移動)
* `U` : 進む(`u`の逆)
* `x` : カーソル上のファイルをデフォルトアプリで開く
* `p` : プレビューを表示
* `P` : 直前に使用していたウィンドウで開く(めっちゃ便利)

* `mb` : 現在のディレクトリをブックマーク
* `mB` : 現在のディレクトリをブックマーク削除
* `qb` : ブックマークと履歴一覧を表示
* `{cnt}gb` : cnt番目のブックマークへ移動
* `{cnt}u` : cnt番目の履歴に戻る
* `let g:netrw_keepdir = 0` : ディレクトリ移動ときにカレントディレクトリも変更する

## ファイルパスの指定方法
* `*/filepat`   カレントディレクトリの、filepat にマッチするファイル
* `**/filepat`  カレントディレクトリとそれ以下のディレクトリの、filepat にマッ
            チするファイル
* `*//pattern`  カレントディレクトリの、pattern を含んでいるファイル (vimgrep
            が使用されます)
* `**//pattern` カレントディレクトリとそれ以下のディレクトリの、pattern を含ん
            でいるファイル (vimgrep が使用されます)

# XXXに対して一気にコマンドを実行したい
* `:tabdo` : 全てのタブにexコマンドを実行
* `:bufdo` : 全てのバッファにexコマンドを実行
* `:cdo` : quickfixの全ての箇所にexコマンドを実行
* `:cfdo` : quickfixに含まれる全てのファイルにexコマンドを実行
* `:argdo` : argsコマンドで設定されている全てのファイルにexコマンドを実行
* `:windo` : 全てのウィンドウにexコマンドを実行

補足)保存も一緒にやる場合にはupdateコマンドにパイプしたら良いらしい
```
:bufdo %s/aaa/bbb/g | update
```
:bufdo

# その他
* `:tab b bufname` : バッファのファイルをタブで開く
* `:argadd filenames` : 複数ファイルをargsリストに加える。(バッファにも)
* `:args filenames` : 上に同じだが、argsリストはリセットされる。

## exコマンドの出力を扱いたい!!
バッファ一覧とか取得したいんじゃー!!  
こんな時には`:redir`を使う。これで出力内容を
ファイルや、変数に格納できる。

### 使用例
以下のようにして、変数`var_name`にバッファ一覧の内容を格納する。
```
:redir => var_name
:ls
:redir END
:echo var_name
```
## 貼り付けのときに勝手にインデントされないように
### 方法1
`:set paste`を設定する。この設定をすればインデントされない。
もとに戻すには`:set nopaste`を使う。
### 方法2
`:a!`を入力して、ペースとして`esc`で終了する。
挿入モードでは`:i!`を使うらしい。



## パス検索
* `:path+=~/memo/**` : 各種補完の際に使われるパスを追加。
なお、`\`は使えないので、`\\`か`/`を代わりに使う。
これに登録して、wildmenuをsetしておけば、`:find vim/ch*`などとタイプして
tabを押すと、`~/memo/vim/cheatsheet.md`を選択でき、すぐに開けるので
超便利!!!

# 最近使ったファイルへ移動
* `:bro[wse] old[files]` : 最近使ったファイル一覧を出して、番号指定して移動
* `:ol[dfiles]` : 最近使ったファイル一覧表示
* `:e #<123` : 最近使ったファイル一覧での123番号のファイルに移動

# tips
* `:verbose set viminfo?` : verboseを使用すると、設定を変更した箇所がわかる
もちろんviminfo以外の設定でも同様
* `%x<C-o>x` : 対応するカッコを消すためのイディオム。％でカッコとじに飛ぶと同時に
移動履歴に開きカッコに位置を設定し、閉じカッコ消したあとに、開かきカッコに戻り消す。
* `caw(<C-r>")` : 単語をカッコで囲むイディオム。`caw`で単語を消し、レジスタに入れ、
`(`入力後にレジスタの値を貼り付け、`)`を入力。
* `:set` : 設定を確認(http://tweeeety.hateblo.jp/entry/2017/04/04/195953)
* `:TOhtml` : 指定範囲をhtmlに変換。スタイルもちゃんと適用され、行数も反映された。結構便利そう。


## root権限で保存
`:w !sudo tee % > /dev/null`でOK

## 起動時間計測
`vim --startuptime hoge.txt`を実行すると、起動時間ログがhoge.txtに出力される。
参考http://massa8080.hatenablog.com/entry/2016/03/04/213359

## モードラインによるファイルごとの設定

```
モードラインの例 その1
/* vim: set ai tw=75: */

モードラインの例 その2
" vim:set ts=8 sts=2 sw=2 tw=0:

モードラインの例 その3
.. vim:set expandtab fenc=utf8 ff=unix ft=rest :
```

補足)
上のモードライン例に書いた内容がこのファイルにも適用されちゃうのに
気づかず、このファイルをvimで編集してて面倒なことになった。

参考:https://nanasi.jp/articles/howto/file/modeline.html
